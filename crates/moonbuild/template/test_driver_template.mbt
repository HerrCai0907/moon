// Generated by moon test.

fn catch_exception[A](body : A, on_exn : A) -> A = "%control.catch"

fn check_panic[A, B](
  f : () -> A,
  does_panic : () -> B,
  no_panic : () -> B
) -> B {
  catch_exception(
    {
      f() |> ignore
      no_panic()
    },
    does_panic(),
  )
}

fn startswith_panic(s : String) -> Bool {
  s.length() >= 5 && s[0] == 'p' && s[1] == 'a' && s[2] == 'n' && s[3] == 'i' &&
  s[4] == 'c'
}

fn main {
  let tests : Array[(String, String, () -> Result[Unit, String])] = [
    // test identifiers
  ]
  let total = tests.length()
  let test_names = Array::make(total, "")
  let filenames = Array::make(total, "")
  let messages = Array::make(total, "")
  let mut succ_idx = total
  let mut fail_idx = 0
  for k = 0; k < tests.length(); k = k + 1 {
    let (filename, name, f) = tests[k]
    filenames[k] = filename
    let result = if startswith_panic(name) {
      check_panic(f, fn() { Result::Ok(()) }, fn() { Err("panic is expected") })
    } else {
      f()
    }
    match result {
      Ok(_) => {
        succ_idx -= 1
        test_names[succ_idx] = name
      }
      Err(e) => {
        test_names[fail_idx] = name
        messages[fail_idx] = e
        fail_idx += 1
      }
    }
  }
  fn repr(obj : Array[String]) -> String {
    let buf = Buffer::new(size_hint=16)
    obj.debug_write(buf)
    buf.to_string()
  }

  let filenames = repr(filenames)
  let test_names = repr(test_names)
  let messages = repr(messages)
  let passed = total - succ_idx
  println("{begin_moontest}")
  println(
    "{\"passed\": \(passed), \"package\": \"{package}\", \"filenames\": \(filenames), \"test_names\": \(test_names), \"messages\": \(messages)}",
  )
  println("{end_moontest}")
}
